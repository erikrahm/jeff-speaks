{"ast":null,"code":"import { createContext } from \"react\";\nimport { keyBy } from \"lodash\";\nimport categories from \"./output/categories.json\";\nimport characters from \"./output/characters.json\";\nimport conditions from \"./output/conditions.json\";\nimport dialogue from \"./output/dialogue.json\";\nimport responses from \"./output/responses.json\";\n\nconst structureData = section => keyBy(section, \"name\");\n\nexport const defaultState = {\n  categories,\n  characters: structureData(characters),\n  conditions: structureData(conditions),\n  dialogue: structureData(dialogue),\n  responses: structureData(responses)\n};\nconst lol = {\n  characters: {\n    item1: {\n      name: \"lol\"\n    }\n  }\n};\n\nconst replaceID = (state, ID) => {\n  const {\n    categories,\n    ...iterableSections\n  } = state;\n  const sections = Object.values(iterableSections);\n  const keys = Object.keys(iterableSections);\n  const rebuilt = {};\n  sections.forEach((section, index) => {\n    const sectionContents = {};\n    const currentKey = keys[index];\n    let k;\n\n    for (k in section) {\n      console.log(\"YOOO: \", k, section[k]);\n    } // rebuilt[currentKey] = sectionContents\n\n  });\n  return state;\n};\n\nexport const appReducer = (state, dispatch) => {\n  const updateState = update => ({ ...state,\n    ...update\n  });\n\n  switch (dispatch.type) {\n    case \"addCategory\":\n      {\n        const payload = dispatch.payload;\n        return updateState({\n          categories: [...state.categories, payload]\n        });\n      }\n\n    case \"removeCategory\":\n      {\n        return updateState({\n          categories: [...state.categories].filter(item => item !== dispatch.payload)\n        });\n      }\n\n    case \"addCharacter\":\n      {\n        const payload = dispatch.payload;\n        return updateState({\n          characters: { ...state.categories,\n            [payload.name]: dispatch.payload\n          }\n        });\n      }\n\n    case \"removeCharacter\":\n      {\n        const payload = dispatch.payload; // Destructuring and spread assignment to remove just the one property and store the rest in updatedCharacters\n\n        const {\n          [payload.name]: value,\n          ...updatedCharacters\n        } = state.characters;\n        return updateState({\n          characters: updatedCharacters\n        });\n      }\n\n    case \"addCondition\":\n      {\n        const payload = dispatch.payload;\n        return updateState({\n          conditions: { ...state.conditions,\n            [payload.name]: payload\n          }\n        });\n      }\n\n    case \"removeCondition\":\n      {\n        const payload = dispatch.payload;\n        const {\n          [payload.name]: value,\n          ...updatedConditions\n        } = state.conditions;\n        return updateState({\n          conditions: updatedConditions\n        });\n      }\n\n    case \"addDialogue\":\n      const payload = dispatch.payload;\n      return updateState({\n        dialogue: { ...state.dialogue,\n          [payload.name]: payload\n        }\n      });\n\n    case \"editDialogue\":\n      {\n        const payload = dispatch.payload; // This means that the ID of the dialogue was edited so we need to update this elsewhere\n\n        if (dispatch.edit !== payload.name) {\n          replaceID(state, payload.name);\n        }\n\n        break;\n      }\n\n    case \"removeDialogue\":\n      {\n        const payload = dispatch.payload;\n        const {\n          [payload.name]: value,\n          ...updatedDialogue\n        } = state.dialogue;\n        return updateState({\n          dialogue: updatedDialogue\n        });\n      }\n\n    case \"addResponse\":\n      {\n        const payload = dispatch.payload;\n        return updateState({\n          responses: { ...state.responses,\n            [payload.name]: payload\n          }\n        });\n      }\n\n    case \"removeResponse\":\n      {\n        const payload = dispatch.payload;\n        const {\n          [payload.name]: value,\n          ...updatedResponses\n        } = state.responses;\n        return updateState({\n          dialogue: updatedResponses\n        });\n      }\n\n    default:\n      throw new Error(\"That ain't right, try using a valid action for the AppState reducer.\");\n  }\n};\nexport const AppContext = /*#__PURE__*/createContext({\n  state: defaultState,\n  dispatch: () => null\n});","map":{"version":3,"sources":["/Users/erik.rahm/dev/jeff-speaks/src/appState.tsx"],"names":["createContext","keyBy","categories","characters","conditions","dialogue","responses","structureData","section","defaultState","lol","item1","name","replaceID","state","ID","iterableSections","sections","Object","values","keys","rebuilt","forEach","index","sectionContents","currentKey","k","console","log","appReducer","dispatch","updateState","update","type","payload","filter","item","value","updatedCharacters","updatedConditions","edit","updatedDialogue","updatedResponses","Error","AppContext"],"mappings":"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","sourcesContent":["import { createContext, Dispatch } from \"react\";\nimport { keyBy } from \"lodash\";\n\nimport categories from \"./output/categories.json\";\nimport characters from \"./output/characters.json\";\nimport conditions from \"./output/conditions.json\";\nimport dialogue from \"./output/dialogue.json\";\nimport responses from \"./output/responses.json\";\n\nexport interface AppState {\n  categories: string[];\n  characters: {\n    [key: string]: Character;\n  };\n  conditions: {\n    [key: string]: Condition;\n  };\n  dialogue: {\n    [key: string]: Dialogue;\n  };\n  responses: {\n    [key: string]: DialogueResponse;\n  };\n}\n\nexport type ObjectAppState = Omit<AppState, \"categories\">;\n\ntype ValueOf<T> = T[keyof T];\n\nexport type Payload =\n  | string\n  | Character\n  | Condition\n  | Dialogue\n  | DialogueResponse;\n\nexport interface AppAction {\n  type: string;\n  payload: Payload;\n  edit?: string;\n}\n\nconst structureData = <T extends Payload>(section: T[]): { [key: string]: T } =>\n  keyBy(section, \"name\");\n\nexport const defaultState: AppState = {\n  categories,\n  characters: structureData<Character>(characters),\n  conditions: structureData<Condition>(conditions),\n  dialogue: structureData<Dialogue>(dialogue),\n  responses: structureData<DialogueResponse>(responses),\n};\n\nconst lol = {\n  characters: {\n    item1: {\n      name: \"lol\",\n    },\n  },\n};\n\nconst replaceID = (state: AppState, ID: string): AppState => {\n  const { categories, ...iterableSections } = state;\n  const sections = Object.values(iterableSections);\n  const keys = Object.keys(iterableSections);\n  const rebuilt: ObjectAppState = {} as ObjectAppState;\n  sections.forEach((section, index) => {\n    const sectionContents: ValueOf<ObjectAppState> = {};\n    const currentKey: keyof ObjectAppState = keys[\n      index\n    ] as keyof ObjectAppState;\n\n    let k: keyof typeof section;\n    for (k in section) {\n      console.log(\"YOOO: \", k, section[k]);\n    }\n\n    // rebuilt[currentKey] = sectionContents\n  });\n  return state;\n};\n\nexport const appReducer = (state: AppState, dispatch: AppAction) => {\n  const updateState = (update: any) => ({ ...state, ...update });\n\n  switch (dispatch.type) {\n    case \"addCategory\": {\n      const payload = dispatch.payload as string;\n      return updateState({\n        categories: [...state.categories, payload],\n      });\n    }\n    case \"removeCategory\": {\n      return updateState({\n        categories: [...state.categories].filter(\n          (item) => item !== dispatch.payload\n        ),\n      });\n    }\n    case \"addCharacter\": {\n      const payload = dispatch.payload as Character;\n      return updateState({\n        characters: { ...state.categories, [payload.name]: dispatch.payload },\n      });\n    }\n    case \"removeCharacter\": {\n      const payload = dispatch.payload as Character;\n      // Destructuring and spread assignment to remove just the one property and store the rest in updatedCharacters\n      const { [payload.name]: value, ...updatedCharacters } = state.characters;\n      return updateState({\n        characters: updatedCharacters,\n      });\n    }\n    case \"addCondition\": {\n      const payload = dispatch.payload as Condition;\n      return updateState({\n        conditions: { ...state.conditions, [payload.name]: payload },\n      });\n    }\n    case \"removeCondition\": {\n      const payload = dispatch.payload as Condition;\n      const { [payload.name]: value, ...updatedConditions } = state.conditions;\n      return updateState({\n        conditions: updatedConditions,\n      });\n    }\n    case \"addDialogue\":\n      const payload = dispatch.payload as Dialogue;\n      return updateState({\n        dialogue: { ...state.dialogue, [payload.name]: payload },\n      });\n    case \"editDialogue\": {\n      const payload = dispatch.payload as Dialogue;\n      // This means that the ID of the dialogue was edited so we need to update this elsewhere\n      if (dispatch.edit !== payload.name) {\n        replaceID(state, payload.name);\n      }\n      break;\n    }\n    case \"removeDialogue\": {\n      const payload = dispatch.payload as Dialogue;\n      const { [payload.name]: value, ...updatedDialogue } = state.dialogue;\n      return updateState({\n        dialogue: updatedDialogue,\n      });\n    }\n    case \"addResponse\": {\n      const payload = dispatch.payload as DialogueResponse;\n      return updateState({\n        responses: { ...state.responses, [payload.name]: payload },\n      });\n    }\n    case \"removeResponse\": {\n      const payload = dispatch.payload as DialogueResponse;\n      const { [payload.name]: value, ...updatedResponses } = state.responses;\n      return updateState({\n        dialogue: updatedResponses,\n      });\n    }\n    default:\n      throw new Error(\n        \"That ain't right, try using a valid action for the AppState reducer.\"\n      );\n  }\n};\n\nexport const AppContext = createContext<{\n  state: AppState;\n  dispatch: Dispatch<AppAction>;\n}>({ state: defaultState as AppState, dispatch: () => null });\n"]},"metadata":{},"sourceType":"module"}