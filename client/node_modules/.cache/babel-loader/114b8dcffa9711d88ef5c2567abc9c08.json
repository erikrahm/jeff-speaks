{"ast":null,"code":"import { createContext } from \"react\";\nimport { keyBy } from \"lodash\";\nimport categories from \"./output/categories.json\";\nimport characters from \"./output/characters.json\";\nimport conditions from \"./output/conditions.json\";\nimport dialogue from \"./output/dialogue.json\";\nimport responses from \"./output/responses.json\";\n\nconst structureData = section => keyBy(section, \"name\");\n\nexport const defaultState = {\n  categories,\n  characters: structureData(characters),\n  conditions: structureData(conditions),\n  dialogue: structureData(dialogue),\n  responses: structureData(responses)\n};\n\nconst replaceID = (state, newID, oldID) => {\n  console.log(\"CALLED\");\n  const {\n    categories,\n    ...iterableSections\n  } = state;\n  const sections = Object.values(iterableSections);\n  const keys = Object.keys(iterableSections);\n  const rebuilt = {};\n  sections.forEach((section, index) => {\n    rebuilt[section.name] = {};\n    let sk;\n\n    for (sk in section) {\n      console.log(\"WOAH: \", sk);\n      const item = section[sk];\n      if (sk === oldID) delete section[sk];\n      section[newID] = item;\n      rebuilt[section.name][sk] = item;\n      console.log(\"OKAY: \", rebuilt);\n      let ik;\n\n      for (ik in item) {\n        console.log(\"HUH: \", ik);\n\n        if (item[ik] === oldID) {\n          item[ik] = newID;\n        }\n      }\n    }\n  });\n  console.log(\"GOTEM: \", sections);\n  return state;\n};\n\nexport const appReducer = (state, dispatch) => {\n  const updateState = update => ({ ...state,\n    ...update\n  });\n\n  switch (dispatch.type) {\n    case \"addCategory\":\n      {\n        const payload = dispatch.payload;\n        return updateState({\n          categories: [...state.categories, payload]\n        });\n      }\n\n    case \"removeCategory\":\n      {\n        return updateState({\n          categories: [...state.categories].filter(item => item !== dispatch.payload)\n        });\n      }\n\n    case \"addCharacter\":\n      {\n        const payload = dispatch.payload;\n        return updateState({\n          characters: { ...state.categories,\n            [payload.name]: dispatch.payload\n          }\n        });\n      }\n\n    case \"removeCharacter\":\n      {\n        const payload = dispatch.payload; // Destructuring and spread assignment to remove just the one property and store the rest in updatedCharacters\n\n        const {\n          [payload.name]: value,\n          ...updatedCharacters\n        } = state.characters;\n        return updateState({\n          characters: updatedCharacters\n        });\n      }\n\n    case \"addCondition\":\n      {\n        const payload = dispatch.payload;\n        return updateState({\n          conditions: { ...state.conditions,\n            [payload.name]: payload\n          }\n        });\n      }\n\n    case \"removeCondition\":\n      {\n        const payload = dispatch.payload;\n        const {\n          [payload.name]: value,\n          ...updatedConditions\n        } = state.conditions;\n        return updateState({\n          conditions: updatedConditions\n        });\n      }\n\n    case \"addDialogue\":\n      const payload = dispatch.payload;\n      return updateState({\n        dialogue: { ...state.dialogue,\n          [payload.name]: payload\n        }\n      });\n\n    case \"editDialogue\":\n      {\n        const payload = dispatch.payload; // This means that the ID of the dialogue was edited so we need to update this elsewhere\n\n        if (dispatch.edit && dispatch.edit !== payload.name) {\n          replaceID(state, payload.name, dispatch.edit);\n        }\n\n        return { ...state\n        };\n      }\n\n    case \"removeDialogue\":\n      {\n        const payload = dispatch.payload;\n        const {\n          [payload.name]: value,\n          ...updatedDialogue\n        } = state.dialogue;\n        return updateState({\n          dialogue: updatedDialogue\n        });\n      }\n\n    case \"addResponse\":\n      {\n        const payload = dispatch.payload;\n        return updateState({\n          responses: { ...state.responses,\n            [payload.name]: payload\n          }\n        });\n      }\n\n    case \"removeResponse\":\n      {\n        const payload = dispatch.payload;\n        const {\n          [payload.name]: value,\n          ...updatedResponses\n        } = state.responses;\n        return updateState({\n          dialogue: updatedResponses\n        });\n      }\n\n    default:\n      throw new Error(\"That ain't right, try using a valid action for the AppState reducer.\");\n  }\n};\nexport const AppContext = /*#__PURE__*/createContext({\n  state: defaultState,\n  dispatch: () => null\n});","map":{"version":3,"sources":["/Users/erik.rahm/dev/jeff-speaks/src/appState.tsx"],"names":["createContext","keyBy","categories","characters","conditions","dialogue","responses","structureData","section","defaultState","replaceID","state","newID","oldID","console","log","iterableSections","sections","Object","values","keys","rebuilt","forEach","index","name","sk","item","ik","appReducer","dispatch","updateState","update","type","payload","filter","value","updatedCharacters","updatedConditions","edit","updatedDialogue","updatedResponses","Error","AppContext"],"mappings":"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","sourcesContent":["import { createContext, Dispatch } from \"react\";\nimport { keyBy } from \"lodash\";\n\nimport categories from \"./output/categories.json\";\nimport characters from \"./output/characters.json\";\nimport conditions from \"./output/conditions.json\";\nimport dialogue from \"./output/dialogue.json\";\nimport responses from \"./output/responses.json\";\n\nexport interface AppState {\n  categories: string[];\n  characters: {\n    [key: string]: Character;\n  };\n  conditions: {\n    [key: string]: Condition;\n  };\n  dialogue: {\n    [key: string]: Dialogue;\n  };\n  responses: {\n    [key: string]: DialogueResponse;\n  };\n}\n\nexport type ObjectAppState = Omit<AppState, \"categories\">;\n\ntype ValueOf<T> = T[keyof T];\n\nexport type Payload =\n  | string\n  | Character\n  | Condition\n  | Dialogue\n  | DialogueResponse;\n\nexport interface AppAction {\n  type: string;\n  payload: Payload;\n  edit?: string;\n}\n\nconst structureData = <T extends Payload>(section: T[]): { [key: string]: T } =>\n  keyBy(section, \"name\");\n\nexport const defaultState: AppState = {\n  categories,\n  characters: structureData<Character>(characters),\n  conditions: structureData<Condition>(conditions),\n  dialogue: structureData<Dialogue>(dialogue),\n  responses: structureData<DialogueResponse>(responses),\n};\n\nconst replaceID = (state: AppState, newID: string, oldID: string): AppState => {\n  console.log(\"CALLED\");\n  const { categories, ...iterableSections } = state;\n  const sections = Object.values(iterableSections);\n  const keys = Object.keys(iterableSections);\n  const rebuilt: any = {};\n  sections.forEach((section, index) => {\n    rebuilt[section.name] = {};\n    let sk: keyof typeof section;\n    for (sk in section) {\n      console.log(\"WOAH: \", sk);\n      const item = section[sk];\n      if (sk === oldID) delete section[sk];\n      section[newID] = item;\n\n      rebuilt[section.name][sk] = item;\n\n      console.log(\"OKAY: \", rebuilt);\n\n      let ik: keyof typeof item;\n      for (ik in item) {\n        console.log(\"HUH: \", ik);\n        if (item[ik] === oldID) {\n          item[ik] = newID;\n        }\n      }\n    }\n  });\n  console.log(\"GOTEM: \", sections);\n  return state;\n};\n\nexport const appReducer = (state: AppState, dispatch: AppAction) => {\n  const updateState = (update: any) => ({ ...state, ...update });\n\n  switch (dispatch.type) {\n    case \"addCategory\": {\n      const payload = dispatch.payload as string;\n      return updateState({\n        categories: [...state.categories, payload],\n      });\n    }\n    case \"removeCategory\": {\n      return updateState({\n        categories: [...state.categories].filter(\n          (item) => item !== dispatch.payload\n        ),\n      });\n    }\n    case \"addCharacter\": {\n      const payload = dispatch.payload as Character;\n      return updateState({\n        characters: { ...state.categories, [payload.name]: dispatch.payload },\n      });\n    }\n    case \"removeCharacter\": {\n      const payload = dispatch.payload as Character;\n      // Destructuring and spread assignment to remove just the one property and store the rest in updatedCharacters\n      const { [payload.name]: value, ...updatedCharacters } = state.characters;\n      return updateState({\n        characters: updatedCharacters,\n      });\n    }\n    case \"addCondition\": {\n      const payload = dispatch.payload as Condition;\n      return updateState({\n        conditions: { ...state.conditions, [payload.name]: payload },\n      });\n    }\n    case \"removeCondition\": {\n      const payload = dispatch.payload as Condition;\n      const { [payload.name]: value, ...updatedConditions } = state.conditions;\n      return updateState({\n        conditions: updatedConditions,\n      });\n    }\n    case \"addDialogue\":\n      const payload = dispatch.payload as Dialogue;\n      return updateState({\n        dialogue: { ...state.dialogue, [payload.name]: payload },\n      });\n    case \"editDialogue\": {\n      const payload = dispatch.payload as Dialogue;\n      // This means that the ID of the dialogue was edited so we need to update this elsewhere\n      if (dispatch.edit && dispatch.edit !== payload.name) {\n        replaceID(state, payload.name, dispatch.edit);\n      }\n      return { ...state };\n    }\n    case \"removeDialogue\": {\n      const payload = dispatch.payload as Dialogue;\n      const { [payload.name]: value, ...updatedDialogue } = state.dialogue;\n      return updateState({\n        dialogue: updatedDialogue,\n      });\n    }\n    case \"addResponse\": {\n      const payload = dispatch.payload as DialogueResponse;\n      return updateState({\n        responses: { ...state.responses, [payload.name]: payload },\n      });\n    }\n    case \"removeResponse\": {\n      const payload = dispatch.payload as DialogueResponse;\n      const { [payload.name]: value, ...updatedResponses } = state.responses;\n      return updateState({\n        dialogue: updatedResponses,\n      });\n    }\n    default:\n      throw new Error(\n        \"That ain't right, try using a valid action for the AppState reducer.\"\n      );\n  }\n};\n\nexport const AppContext = createContext<{\n  state: AppState;\n  dispatch: Dispatch<AppAction>;\n}>({ state: defaultState as AppState, dispatch: () => null });\n"]},"metadata":{},"sourceType":"module"}