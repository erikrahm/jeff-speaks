{"ast":null,"code":"import { createContext } from \"react\";\nimport { cloneDeep, keyBy } from \"lodash\";\nimport categories from \"./output/categories.json\";\nimport characters from \"./output/characters.json\";\nimport conditions from \"./output/conditions.json\";\nimport dialogue from \"./output/dialogue.json\";\nimport responses from \"./output/responses.json\";\n\nconst structureData = section => keyBy(section, \"name\");\n\nexport const defaultState = {\n  categories,\n  characters: structureData(characters),\n  conditions: structureData(conditions),\n  dialogue: structureData(dialogue),\n  responses: structureData(responses)\n};\n\nconst replaceID = (state, newID, oldID) => {\n  const {\n    categories,\n    ...iterableSections\n  } = cloneDeep(state);\n  const keys = Object.keys(iterableSections);\n  const rebuilt = {};\n  Object.values(iterableSections).forEach((section, index) => {\n    rebuilt[keys[index]] = {};\n    let sk;\n\n    for (sk in section) {\n      rebuilt[keys[index]][sk === oldID ? newID : sk] = section[sk];\n      const item = rebuilt[keys[index]][sk === oldID ? newID : sk];\n      let ik;\n\n      for (ik in item) {\n        if (item[ik] === oldID) {\n          item[ik] = newID;\n        }\n      }\n    }\n  });\n  return {\n    categories,\n    ...rebuilt\n  };\n};\n\nexport const appReducer = (state, dispatch) => {\n  const updateState = update => ({ ...state,\n    ...update\n  });\n\n  switch (dispatch.type) {\n    case \"addCategory\":\n      {\n        const payload = dispatch.payload;\n        return updateState({\n          categories: [...state.categories, payload]\n        });\n      }\n\n    case \"removeCategory\":\n      {\n        return updateState({\n          categories: [...state.categories].filter(item => item !== dispatch.payload)\n        });\n      }\n\n    case \"addCharacter\":\n      {\n        const payload = dispatch.payload;\n        return updateState({\n          characters: { ...state.categories,\n            [payload.name]: dispatch.payload\n          }\n        });\n      }\n\n    case \"removeCharacter\":\n      {\n        const payload = dispatch.payload; // Destructuring and spread assignment to remove just the one property and store the rest in updatedCharacters\n\n        const {\n          [payload.name]: value,\n          ...updatedCharacters\n        } = state.characters;\n        return updateState({\n          characters: updatedCharacters\n        });\n      }\n\n    case \"addCondition\":\n      {\n        const payload = dispatch.payload;\n        return updateState({\n          conditions: { ...state.conditions,\n            [payload.name]: payload\n          }\n        });\n      }\n\n    case \"removeCondition\":\n      {\n        const payload = dispatch.payload;\n        const {\n          [payload.name]: value,\n          ...updatedConditions\n        } = state.conditions;\n        return updateState({\n          conditions: updatedConditions\n        });\n      }\n\n    case \"addDialogue\":\n      const payload = dispatch.payload;\n      return updateState({\n        dialogue: { ...state.dialogue,\n          [payload.name]: payload\n        }\n      });\n\n    case \"editDialogue\":\n      {\n        const payload = dispatch.payload;\n        let tempState = state; // This means that the ID of the dialogue was edited so we need to update this elsewhere\n\n        if (dispatch.edit && dispatch.edit !== payload.name) {\n          tempState = replaceID(state, payload.name, dispatch.edit);\n          console.log(\"TEMP: \", tempState);\n        }\n\n        return { ...tempState,\n          dialogue: { ...tempState.dialogue,\n            [payload.name]: payload\n          }\n        };\n      }\n\n    case \"removeDialogue\":\n      {\n        const payload = dispatch.payload;\n        const {\n          [payload.name]: value,\n          ...updatedDialogue\n        } = state.dialogue;\n        return updateState({\n          dialogue: updatedDialogue\n        });\n      }\n\n    case \"addResponse\":\n      {\n        const payload = dispatch.payload;\n        return updateState({\n          responses: { ...state.responses,\n            [payload.name]: payload\n          }\n        });\n      }\n\n    case \"removeResponse\":\n      {\n        const payload = dispatch.payload;\n        const {\n          [payload.name]: value,\n          ...updatedResponses\n        } = state.responses;\n        return updateState({\n          dialogue: updatedResponses\n        });\n      }\n\n    default:\n      throw new Error(\"That ain't right, try using a valid action for the AppState reducer.\");\n  }\n};\nexport const AppContext = /*#__PURE__*/createContext({\n  state: defaultState,\n  dispatch: () => null\n});","map":{"version":3,"sources":["/Users/erik.rahm/dev/jeff-speaks/src/appState.tsx"],"names":["createContext","cloneDeep","keyBy","categories","characters","conditions","dialogue","responses","structureData","section","defaultState","replaceID","state","newID","oldID","iterableSections","keys","Object","rebuilt","values","forEach","index","sk","item","ik","appReducer","dispatch","updateState","update","type","payload","filter","name","value","updatedCharacters","updatedConditions","tempState","edit","console","log","updatedDialogue","updatedResponses","Error","AppContext"],"mappings":"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","sourcesContent":["import { createContext, Dispatch } from \"react\";\nimport { cloneDeep, keyBy } from \"lodash\";\n\nimport categories from \"./output/categories.json\";\nimport characters from \"./output/characters.json\";\nimport conditions from \"./output/conditions.json\";\nimport dialogue from \"./output/dialogue.json\";\nimport responses from \"./output/responses.json\";\n\nexport interface AppState {\n  categories: string[];\n  characters: {\n    [key: string]: Character;\n  };\n  conditions: {\n    [key: string]: Condition;\n  };\n  dialogue: {\n    [key: string]: Dialogue;\n  };\n  responses: {\n    [key: string]: DialogueResponse;\n  };\n}\n\nexport type ObjectAppState = Omit<AppState, \"categories\">;\n\ntype ValueOf<T> = T[keyof T];\n\nexport type Payload =\n  | string\n  | Character\n  | Condition\n  | Dialogue\n  | DialogueResponse;\n\nexport interface AppAction {\n  type: string;\n  payload: Payload;\n  edit?: string;\n}\n\nconst structureData = <T extends Payload>(section: T[]): { [key: string]: T } =>\n  keyBy(section, \"name\");\n\nexport const defaultState: AppState = {\n  categories,\n  characters: structureData<Character>(characters),\n  conditions: structureData<Condition>(conditions),\n  dialogue: structureData<Dialogue>(dialogue),\n  responses: structureData<DialogueResponse>(responses),\n};\n\nconst replaceID = (state: AppState, newID: string, oldID: string): AppState => {\n  const { categories, ...iterableSections } = cloneDeep(state);\n  const keys = Object.keys(iterableSections);\n  const rebuilt: any = {};\n\n  Object.values(iterableSections).forEach((section, index) => {\n    rebuilt[keys[index]] = {};\n\n    let sk: keyof typeof section;\n    for (sk in section) {\n      rebuilt[keys[index]][sk === oldID ? newID : sk] = section[sk];\n      const item = rebuilt[keys[index]][sk === oldID ? newID : sk];\n\n      let ik: keyof typeof item;\n      for (ik in item) {\n        if (item[ik] === oldID) {\n          item[ik] = newID;\n        }\n      }\n    }\n  });\n  return { categories, ...rebuilt } as AppState;\n};\n\nexport const appReducer = (state: AppState, dispatch: AppAction) => {\n  const updateState = (update: any) => ({ ...state, ...update });\n\n  switch (dispatch.type) {\n    case \"addCategory\": {\n      const payload = dispatch.payload as string;\n      return updateState({\n        categories: [...state.categories, payload],\n      });\n    }\n    case \"removeCategory\": {\n      return updateState({\n        categories: [...state.categories].filter(\n          (item) => item !== dispatch.payload\n        ),\n      });\n    }\n    case \"addCharacter\": {\n      const payload = dispatch.payload as Character;\n      return updateState({\n        characters: { ...state.categories, [payload.name]: dispatch.payload },\n      });\n    }\n    case \"removeCharacter\": {\n      const payload = dispatch.payload as Character;\n      // Destructuring and spread assignment to remove just the one property and store the rest in updatedCharacters\n      const { [payload.name]: value, ...updatedCharacters } = state.characters;\n      return updateState({\n        characters: updatedCharacters,\n      });\n    }\n    case \"addCondition\": {\n      const payload = dispatch.payload as Condition;\n      return updateState({\n        conditions: { ...state.conditions, [payload.name]: payload },\n      });\n    }\n    case \"removeCondition\": {\n      const payload = dispatch.payload as Condition;\n      const { [payload.name]: value, ...updatedConditions } = state.conditions;\n      return updateState({\n        conditions: updatedConditions,\n      });\n    }\n    case \"addDialogue\":\n      const payload = dispatch.payload as Dialogue;\n      return updateState({\n        dialogue: { ...state.dialogue, [payload.name]: payload },\n      });\n    case \"editDialogue\": {\n      const payload = dispatch.payload as Dialogue;\n      let tempState = state;\n\n      // This means that the ID of the dialogue was edited so we need to update this elsewhere\n      if (dispatch.edit && dispatch.edit !== payload.name) {\n        tempState = replaceID(state, payload.name, dispatch.edit);\n        console.log(\"TEMP: \", tempState);\n      }\n      return {\n        ...tempState,\n        dialogue: { ...tempState.dialogue, [payload.name]: payload },\n      };\n    }\n    case \"removeDialogue\": {\n      const payload = dispatch.payload as Dialogue;\n      const { [payload.name]: value, ...updatedDialogue } = state.dialogue;\n      return updateState({\n        dialogue: updatedDialogue,\n      });\n    }\n    case \"addResponse\": {\n      const payload = dispatch.payload as DialogueResponse;\n      return updateState({\n        responses: { ...state.responses, [payload.name]: payload },\n      });\n    }\n    case \"removeResponse\": {\n      const payload = dispatch.payload as DialogueResponse;\n      const { [payload.name]: value, ...updatedResponses } = state.responses;\n      return updateState({\n        dialogue: updatedResponses,\n      });\n    }\n    default:\n      throw new Error(\n        \"That ain't right, try using a valid action for the AppState reducer.\"\n      );\n  }\n};\n\nexport const AppContext = createContext<{\n  state: AppState;\n  dispatch: Dispatch<AppAction>;\n}>({ state: defaultState as AppState, dispatch: () => null });\n"]},"metadata":{},"sourceType":"module"}