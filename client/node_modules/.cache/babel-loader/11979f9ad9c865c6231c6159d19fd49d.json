{"ast":null,"code":"import { createContext } from \"react\";\nimport { cloneDeep, keyBy, without } from \"lodash\";\nimport categories from \"./output/categories.json\";\nimport characters from \"./output/characters.json\";\nimport conditions from \"./output/conditions.json\";\nimport dialogue from \"./output/dialogue.json\";\nimport responses from \"./output/responses.json\";\n\nconst structureData = section => keyBy(section, \"name\");\n\nexport const defaultState = {\n  categories,\n  characters: structureData(characters),\n  conditions: structureData(conditions),\n  dialogue: structureData(dialogue),\n  responses: structureData(responses)\n};\n\nconst replaceID = (state, newID, oldID) => {\n  const {\n    categories,\n    ...iterableSections\n  } = cloneDeep(state);\n  const keys = Object.keys(iterableSections);\n  const rebuilt = {};\n  Object.values(iterableSections).forEach((section, index) => {\n    rebuilt[keys[index]] = {};\n    let sk;\n\n    for (sk in section) {\n      const correctKey = sk === oldID ? newID : sk;\n      rebuilt[keys[index]][correctKey] = section[sk];\n      const item = rebuilt[keys[index]][correctKey];\n      let ik;\n\n      for (ik in item) {\n        if (item[ik] === oldID) {\n          item[ik] = newID;\n        }\n      }\n    }\n  });\n  return {\n    categories,\n    ...rebuilt\n  };\n};\n\nexport const appReducer = (state, dispatch) => {\n  const updateState = update => ({ ...state,\n    ...update\n  });\n\n  switch (dispatch.type) {\n    case \"addCategory\":\n      {\n        const payload = dispatch.payload;\n        const updated = [...state.categories, payload];\n        updated.sort();\n        return updateState({\n          categories: updated\n        });\n      }\n\n    case \"editCategory\":\n      {\n        const payload = dispatch.payload;\n        const tempState = [...without(state.categories, dispatch.edit), payload].sort();\n        console.log(\"temp-state: \", tempState);\n        return updateState({\n          categories: tempState\n        });\n      }\n\n    case \"removeCategory\":\n      {\n        return updateState({\n          categories: [...state.categories].filter(item => item !== dispatch.payload)\n        });\n      }\n\n    case \"addCharacter\":\n      {\n        const payload = dispatch.payload;\n        return updateState({\n          characters: { ...state.categories,\n            [payload.name]: dispatch.payload\n          }\n        });\n      }\n\n    case \"removeCharacter\":\n      {\n        const payload = dispatch.payload; // Destructuring and spread assignment to remove just the one property and store the rest in updatedCharacters\n\n        const {\n          [payload.name]: value,\n          ...updatedCharacters\n        } = state.characters;\n        return updateState({\n          characters: updatedCharacters\n        });\n      }\n\n    case \"addCondition\":\n      {\n        const payload = dispatch.payload;\n        return updateState({\n          conditions: { ...state.conditions,\n            [payload.name]: payload\n          }\n        });\n      }\n\n    case \"removeCondition\":\n      {\n        const payload = dispatch.payload;\n        const {\n          [payload.name]: value,\n          ...updatedConditions\n        } = state.conditions;\n        return updateState({\n          conditions: updatedConditions\n        });\n      }\n\n    case \"addDialogue\":\n      const payload = dispatch.payload;\n      return updateState({\n        dialogue: { ...state.dialogue,\n          [payload.name]: payload\n        }\n      });\n\n    case \"editDialogue\":\n      {\n        const payload = dispatch.payload;\n        let tempState = state; // This means that the ID of the dialogue was edited so we need to update this elsewhere\n\n        if (dispatch.edit && dispatch.edit !== payload.name) {\n          tempState = replaceID(state, payload.name, dispatch.edit);\n        }\n\n        tempState.dialogue[payload.name] = payload;\n        return updateState({ ...tempState\n        });\n      }\n\n    case \"removeDialogue\":\n      {\n        const payload = dispatch.payload;\n        const {\n          [payload.name]: value,\n          ...updatedDialogue\n        } = state.dialogue;\n        return updateState({\n          dialogue: updatedDialogue\n        });\n      }\n\n    case \"addResponse\":\n      {\n        const payload = dispatch.payload;\n        return updateState({\n          responses: { ...state.responses,\n            [payload.name]: payload\n          }\n        });\n      }\n\n    case \"editResponse\":\n      {\n        const payload = dispatch.payload;\n        let tempState = state; // This means that the ID of the dialogue was edited so we need to update this elsewhere\n\n        if (dispatch.edit && dispatch.edit !== payload.name) {\n          tempState = replaceID(state, payload.name, dispatch.edit);\n        }\n\n        tempState.responses[payload.name] = payload;\n        return updateState({ ...tempState\n        });\n      }\n\n    case \"removeResponse\":\n      {\n        const payload = dispatch.payload;\n        const {\n          [payload.name]: value,\n          ...updatedResponses\n        } = state.responses;\n        return updateState({\n          dialogue: updatedResponses\n        });\n      }\n\n    case \"saveFiles\":\n      {\n        (async () => {\n          await fetch(\"http://localhost:8080/save\", {\n            method: \"POST\",\n            // *GET, POST, PUT, DELETE, etc.\n            mode: \"cors\",\n            // no-cors, *cors, same-origin\n            cache: \"no-cache\",\n            // *default, no-cache, reload, force-cache, only-if-cached\n            credentials: \"same-origin\",\n            // include, *same-origin, omit\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            redirect: \"follow\",\n            // manual, *follow, error\n            referrerPolicy: \"no-referrer\",\n            // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url\n            body: JSON.stringify(state) // body data type must match \"Content-Type\" header\n\n          }).then(response => response.json()).then(data => console.log(data));\n        })();\n\n        return updateState({});\n      }\n\n    default:\n      throw new Error(\"That ain't right, try using a valid action for the AppState reducer.\");\n  }\n};\nexport const AppContext = /*#__PURE__*/createContext({\n  state: defaultState,\n  dispatch: () => null\n});","map":{"version":3,"sources":["/Users/erik.rahm/dev/jeff-speaks/client/src/appState.tsx"],"names":["createContext","cloneDeep","keyBy","without","categories","characters","conditions","dialogue","responses","structureData","section","defaultState","replaceID","state","newID","oldID","iterableSections","keys","Object","rebuilt","values","forEach","index","sk","correctKey","item","ik","appReducer","dispatch","updateState","update","type","payload","updated","sort","tempState","edit","console","log","filter","name","value","updatedCharacters","updatedConditions","updatedDialogue","updatedResponses","fetch","method","mode","cache","credentials","headers","redirect","referrerPolicy","body","JSON","stringify","then","response","json","data","Error","AppContext"],"mappings":"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","sourcesContent":["import { createContext, Dispatch } from \"react\";\nimport { cloneDeep, keyBy, without } from \"lodash\";\n\nimport categories from \"./output/categories.json\";\nimport characters from \"./output/characters.json\";\nimport conditions from \"./output/conditions.json\";\nimport dialogue from \"./output/dialogue.json\";\nimport responses from \"./output/responses.json\";\n\nexport interface AppState {\n  categories: string[];\n  characters: {\n    [key: string]: Character;\n  };\n  conditions: {\n    [key: string]: Condition;\n  };\n  dialogue: {\n    [key: string]: Dialogue;\n  };\n  responses: {\n    [key: string]: DialogueResponse;\n  };\n}\n\nexport type ObjectAppState = Omit<AppState, \"categories\">;\n\ntype ValueOf<T> = T[keyof T];\n\nexport type Payload =\n  | string\n  | Character\n  | Condition\n  | Dialogue\n  | DialogueResponse;\n\nexport interface AppAction {\n  type: string;\n  payload: Payload;\n  edit?: string;\n}\n\nconst structureData = <T extends Payload>(section: T[]): { [key: string]: T } =>\n  keyBy(section, \"name\");\n\nexport const defaultState: AppState = {\n  categories,\n  characters: structureData<Character>(characters),\n  conditions: structureData<Condition>(conditions),\n  dialogue: structureData<Dialogue>(dialogue),\n  responses: structureData<DialogueResponse>(responses),\n};\n\nconst replaceID = (state: AppState, newID: string, oldID: string): AppState => {\n  const { categories, ...iterableSections } = cloneDeep(state);\n  const keys = Object.keys(iterableSections);\n  const rebuilt: any = {};\n\n  Object.values(iterableSections).forEach((section, index) => {\n    rebuilt[keys[index]] = {};\n\n    let sk: keyof typeof section;\n    for (sk in section) {\n      const correctKey = sk === oldID ? newID : sk;\n      rebuilt[keys[index]][correctKey] = section[sk];\n      const item = rebuilt[keys[index]][correctKey];\n\n      let ik: keyof typeof item;\n      for (ik in item) {\n        if (item[ik] === oldID) {\n          item[ik] = newID;\n        }\n      }\n    }\n  });\n  return { categories, ...rebuilt } as AppState;\n};\n\nexport const appReducer = (state: AppState, dispatch: AppAction) => {\n  const updateState = (update: any) => ({ ...state, ...update });\n\n  switch (dispatch.type) {\n    case \"addCategory\": {\n      const payload = dispatch.payload as string;\n      const updated = [...state.categories, payload];\n      updated.sort();\n      return updateState({\n        categories: updated,\n      });\n    }\n    case \"editCategory\": {\n      const payload = dispatch.payload as string;\n      const tempState = [\n        ...without(state.categories, dispatch.edit),\n        payload,\n      ].sort();\n\n      console.log(\"temp-state: \", tempState);\n\n      return updateState({\n        categories: tempState,\n      });\n    }\n    case \"removeCategory\": {\n      return updateState({\n        categories: [...state.categories].filter(\n          (item) => item !== dispatch.payload\n        ),\n      });\n    }\n    case \"addCharacter\": {\n      const payload = dispatch.payload as Character;\n      return updateState({\n        characters: { ...state.categories, [payload.name]: dispatch.payload },\n      });\n    }\n    case \"removeCharacter\": {\n      const payload = dispatch.payload as Character;\n      // Destructuring and spread assignment to remove just the one property and store the rest in updatedCharacters\n      const { [payload.name]: value, ...updatedCharacters } = state.characters;\n      return updateState({\n        characters: updatedCharacters,\n      });\n    }\n    case \"addCondition\": {\n      const payload = dispatch.payload as Condition;\n      return updateState({\n        conditions: { ...state.conditions, [payload.name]: payload },\n      });\n    }\n    case \"removeCondition\": {\n      const payload = dispatch.payload as Condition;\n      const { [payload.name]: value, ...updatedConditions } = state.conditions;\n      return updateState({\n        conditions: updatedConditions,\n      });\n    }\n    case \"addDialogue\":\n      const payload = dispatch.payload as Dialogue;\n      return updateState({\n        dialogue: { ...state.dialogue, [payload.name]: payload },\n      });\n    case \"editDialogue\": {\n      const payload = dispatch.payload as Dialogue;\n      let tempState = state;\n\n      // This means that the ID of the dialogue was edited so we need to update this elsewhere\n      if (dispatch.edit && dispatch.edit !== payload.name) {\n        tempState = replaceID(state, payload.name, dispatch.edit);\n      }\n\n      tempState.dialogue[payload.name] = payload;\n\n      return updateState({\n        ...tempState,\n      });\n    }\n    case \"removeDialogue\": {\n      const payload = dispatch.payload as Dialogue;\n      const { [payload.name]: value, ...updatedDialogue } = state.dialogue;\n      return updateState({\n        dialogue: updatedDialogue,\n      });\n    }\n    case \"addResponse\": {\n      const payload = dispatch.payload as DialogueResponse;\n      return updateState({\n        responses: { ...state.responses, [payload.name]: payload },\n      });\n    }\n    case \"editResponse\": {\n      const payload = dispatch.payload as DialogueResponse;\n      let tempState = state;\n\n      // This means that the ID of the dialogue was edited so we need to update this elsewhere\n      if (dispatch.edit && dispatch.edit !== payload.name) {\n        tempState = replaceID(state, payload.name, dispatch.edit);\n      }\n\n      tempState.responses[payload.name] = payload;\n\n      return updateState({\n        ...tempState,\n      });\n    }\n    case \"removeResponse\": {\n      const payload = dispatch.payload as DialogueResponse;\n      const { [payload.name]: value, ...updatedResponses } = state.responses;\n      return updateState({\n        dialogue: updatedResponses,\n      });\n    }\n    case \"saveFiles\": {\n      (async () => {\n        await fetch(\"http://localhost:8080/save\", {\n          method: \"POST\", // *GET, POST, PUT, DELETE, etc.\n          mode: \"cors\", // no-cors, *cors, same-origin\n          cache: \"no-cache\", // *default, no-cache, reload, force-cache, only-if-cached\n          credentials: \"same-origin\", // include, *same-origin, omit\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          redirect: \"follow\", // manual, *follow, error\n          referrerPolicy: \"no-referrer\", // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url\n          body: JSON.stringify(state), // body data type must match \"Content-Type\" header\n        })\n          .then((response) => response.json())\n          .then((data) => console.log(data));\n      })();\n      return updateState({});\n    }\n    default:\n      throw new Error(\n        \"That ain't right, try using a valid action for the AppState reducer.\"\n      );\n  }\n};\n\nexport const AppContext = createContext<{\n  state: AppState;\n  dispatch: Dispatch<AppAction>;\n}>({ state: defaultState as AppState, dispatch: () => null });\n"]},"metadata":{},"sourceType":"module"}